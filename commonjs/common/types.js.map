{"version":3,"file":"types.js","sourceRoot":"","sources":["../../src/common/types.ts"],"names":[],"mappings":"","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { KeyboardEvent, ReactNode } from 'react';\nimport { List } from 'immutable';\nimport { HeaderRowType, UpdateActions } from './enums';\n\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n\nexport type SelectedRow<TRow> = TRow & { isSelected: boolean };\n\ninterface ColumnValue<TRow, TDependentValue = unknown, TField extends keyof TRow = keyof TRow> {\n  /** The name of the column. By default it will be displayed in the header cell */\n  name: string;\n  /** A unique key to distinguish each column */\n  key: TField;\n  /** Column width. If not specified, it will be determined automatically based on grid width and specified widths of other columns*/\n  width?: number;\n  hidden?: boolean;\n  cellClass?: string;\n  /** By adding an event object with callbacks for the native react events you can bind events to a specific column. That will not break the default behaviour of the grid and will run only for the specified column */\n  events?: {\n    [key: string]: undefined | ((e: Event, info: ColumnEventInfo<TRow>) => void);\n  };\n  /** Formatter to be used to render the cell content */\n  formatter?: React.ReactElement | React.ComponentType<FormatterProps<TRow[TField], TDependentValue, TRow>>;\n  /** Enables cell editing. If set and no editor property specified, then a textinput will be used as the cell editor */\n  editable?: boolean | ((rowData: TRow) => boolean);\n  /** Enable dragging of a column */\n  draggable?: boolean;\n  /** Enable filtering of a column */\n  filterable?: boolean;\n  /** Determines whether column is frozen or not */\n  frozen?: boolean;\n  /** Enable resizing of a column */\n  resizable?: boolean;\n  /** Enable sorting of a column */\n  sortable?: boolean;\n  /** Sets the column sort order to be descending instead of ascending the first time the column is sorted */\n  sortDescendingFirst?: boolean;\n  /** Editor to be rendered when cell of column is being edited. If set, then the column is automatically set to be editable */\n  editor?: React.ReactElement | React.ComponentType<EditorProps<TRow[TField], TDependentValue, TRow>>;\n  /** Header renderer for each header cell */\n  headerRenderer?: React.ReactElement | React.ComponentType<HeaderRowProps<TRow>>;\n  /** Component to be used to filter the data of the column */\n  filterRenderer?: React.ComponentType<FilterRendererProps<TRow, TDependentValue>>;\n\n  // TODO: these props are only used by checkbox editor and we should remove them\n  onCellChange?(rowIdx: number, key: keyof TRow, dependentValues: TDependentValue, event: React.SyntheticEvent): void;\n  getRowMetaData?(rowData: TRow, column: CalculatedColumn<TRow, TDependentValue>): TDependentValue;\n}\n\nexport type Column<TRow, TDependentValue = unknown, TField extends keyof TRow = keyof TRow> =\n  TField extends keyof TRow ? ColumnValue<TRow, TDependentValue, TField> : never;\n\nexport type CalculatedColumn<TRow, TDependentValue = unknown, TField extends keyof TRow = keyof TRow> =\n  Column<TRow, TDependentValue, TField> & {\n    idx: number;\n    width: number;\n    left: number;\n  };\n\nexport type ColumnList<TRow> = Column<TRow>[] | List<Column<TRow>>;\n\nexport interface ColumnMetrics<TRow> {\n  columns: CalculatedColumn<TRow>[];\n  width: number;\n  totalColumnWidth: number;\n  totalWidth: number;\n  minColumnWidth: number;\n}\n\nexport interface RowData {\n  name?: string;\n  get?(key: PropertyKey): unknown;\n  __metaData?: RowGroupMetaData;\n}\n\nexport interface CellMetaData<TRow> {\n  rowKey: keyof TRow;\n  onCellClick(position: Position): void;\n  onCellContextMenu(position: Position): void;\n  onCellDoubleClick(position: Position): void;\n  onDragEnter(overRowIdx: number): void;\n  onCellExpand?(options: SubRowOptions<TRow>): void;\n  onRowExpandToggle?(e: RowExpandToggleEvent): void;\n  onCellMouseDown?(position: Position): void;\n  onCellMouseEnter?(position: Position): void;\n  onAddSubRow?(): void;\n  onDeleteSubRow?(options: SubRowOptions<TRow>): void;\n  getCellActions?(column: CalculatedColumn<TRow>, rowData: TRow): CellActionButton[] | undefined;\n}\n\nexport interface Position {\n  idx: number;\n  rowIdx: number;\n}\n\nexport interface Range {\n  topLeft: Position;\n  bottomRight: Position;\n}\n\nexport interface SelectedRange extends Range {\n  startCell: Position | null;\n  cursorCell: Position | null;\n  isDragging: boolean;\n}\n\nexport interface Dimension {\n  width: number;\n  height: number;\n  top: number;\n  left: number;\n  zIndex: number;\n}\n\nexport type RowGetter<TRow> = (rowIdx: number) => TRow;\n\nexport interface Editor<TValue = never> extends React.Component {\n  getInputNode(): Element | Text | undefined | null;\n  getValue(): TValue;\n  hasResults?(): boolean;\n  isSelectOpen?(): boolean;\n  validate?(value: unknown): boolean;\n  readonly disableContainerStyles?: boolean;\n}\n\nexport interface FormatterProps<TValue, TDependentValue = unknown, TRow = any> {\n  rowIdx: number;\n  value: TValue;\n  column: CalculatedColumn<TRow, TDependentValue>;\n  row: TRow;\n  isScrolling: boolean;\n  dependentValues?: TDependentValue;\n}\n\nexport interface EditorProps<TValue, TDependentValue = unknown, TRow = any> {\n  column: CalculatedColumn<TRow, TDependentValue>;\n  value: TValue;\n  rowMetaData?: TDependentValue;\n  rowData: TRow;\n  height: number;\n  onCommit(args?: { key?: string }): void;\n  onCommitCancel(): void;\n  onBlur(): void;\n  onOverrideKeyDown(e: KeyboardEvent): void;\n}\n\nexport interface HeaderRowProps<TRow> {\n  column: CalculatedColumn<TRow>;\n  rowType: HeaderRowType;\n}\n\nexport interface CellRendererProps<TRow, TValue = unknown> {\n  idx: number;\n  rowIdx: number;\n  height: number;\n  value: TValue;\n  column: CalculatedColumn<TRow>;\n  rowData: TRow;\n  cellMetaData: CellMetaData<TRow>;\n  isScrolling: boolean;\n  scrollLeft: number;\n  isRowSelected?: boolean;\n  expandableOptions?: ExpandableOptions;\n  lastFrozenColumnIndex?: number;\n}\n\nexport interface RowRendererProps<TRow> {\n  height: number;\n  columns: CalculatedColumn<TRow>[];\n  row: TRow;\n  cellRenderer?: React.ComponentType<CellRendererProps<TRow>>;\n  cellMetaData: CellMetaData<TRow>;\n  isSelected?: boolean;\n  idx: number;\n  extraClasses?: string;\n  subRowDetails?: SubRowDetails;\n  colOverscanStartIdx: number;\n  colOverscanEndIdx: number;\n  isScrolling: boolean;\n  scrollLeft: number;\n  lastFrozenColumnIndex?: number;\n}\n\nexport interface FilterRendererProps<TRow, TFilterValue = unknown> {\n  column: CalculatedColumn<TRow>;\n  onChange?(event: AddFilterEvent<TRow>): void;\n  /** TODO: remove */\n  getValidFilterValues?(columnKey: keyof TRow): TFilterValue;\n}\n\nexport interface SubRowDetails<TChildRow = unknown> {\n  canExpand: boolean;\n  field: string;\n  expanded: boolean;\n  children: TChildRow[];\n  treeDepth: number;\n  siblingIndex: number;\n  numberSiblings: number;\n  group?: boolean;\n}\n\nexport interface SubRowOptions<TRow, TChildRow = unknown> {\n  rowIdx: number;\n  idx: number;\n  rowData: TRow;\n  expandArgs?: ExpandableOptions<TChildRow>;\n}\n\nexport interface ExpandableOptions<TChildRow = unknown> {\n  canExpand: boolean;\n  field: string;\n  expanded: boolean;\n  children: TChildRow[];\n  treeDepth: number;\n  subRowDetails: SubRowDetails;\n}\n\ninterface Action {\n  text: ReactNode;\n  callback(): void;\n}\n\nexport interface CellActionButton {\n  icon: ReactNode;\n  actions?: Action[];\n  callback?(): void;\n}\n\nexport interface ColumnEventInfo<TRow> extends Position {\n  rowId: unknown;\n  column: CalculatedColumn<TRow>;\n}\n\nexport interface CellRenderer {\n  setScrollLeft(scrollLeft: number): void;\n}\n\nexport interface RowRenderer<TRow> {\n  setScrollLeft(scrollLeft: number): void;\n  getRowTop?(): number;\n  getRowHeight?(): number;\n  getDecoratedComponentInstance?(idx: number): { row: RowRenderer<TRow> & React.Component<RowRendererProps<TRow>> } | undefined;\n}\n\nexport interface ScrollPosition {\n  scrollLeft: number;\n  scrollTop: number;\n}\n\nexport interface InteractionMasksMetaData<TRow> {\n  onCheckCellIsEditable?(e: CheckCellIsEditableEvent<TRow>): boolean;\n  onCellCopyPaste?(e: CellCopyPasteEvent<TRow>): void;\n  onGridRowsUpdated(\n    cellKey: keyof TRow,\n    toRow1: number,\n    toRow2: number,\n    data: { [key: string]: unknown }, // FIX ME: Use Pick<R, K>\n    updateAction: UpdateActions,\n    fromRow?: number\n  ): void;\n  onDragHandleDoubleClick(data: Position & { rowData: TRow }): void;\n  onCellSelected?(position: Position): void;\n  onCellDeSelected?(position: Position): void;\n  onCellRangeSelectionStarted?(selectedRange: SelectedRange): void;\n  onCellRangeSelectionUpdated?(selectedRange: SelectedRange): void;\n  onCellRangeSelectionCompleted?(selectedRange: SelectedRange): void;\n  onCommit(e: CommitEvent<TRow>): void;\n}\n\nexport interface RowGroupMetaData {\n  isGroup: boolean;\n  treeDepth: number;\n  isExpanded: boolean;\n  columnGroupName: string;\n  columnGroupDisplayName: string;\n  getRowRenderer?(props: unknown, rowIdx: number): React.ReactElement;\n}\n\nexport type RowSelection = { indexes?: number[] } | { isSelectedKey?: string } | { keys?: { values: unknown[]; rowKey: string } };\n\nexport interface HeaderRowData<TRow> {\n  rowType: HeaderRowType;\n  height: number;\n  filterable?: boolean;\n  onFilterChange?(args: AddFilterEvent<TRow>): void;\n}\n\nexport interface AddFilterEvent<TRow> {\n  filterTerm: string;\n  column: Column<TRow>;\n}\n\nexport interface CommitEvent<TRow, TUpdatedValue = never> {\n  cellKey: keyof TRow;\n  rowIdx: number;\n  updated: TUpdatedValue;\n  key?: string;\n}\n\nexport interface RowExpandToggleEvent {\n  rowIdx: number;\n  shouldExpand: boolean;\n  columnGroupName: string;\n  name: string;\n}\n\nexport interface GridRowsUpdatedEvent<TRow, TUpdatedValue = never> {\n  cellKey: keyof TRow;\n  fromRow: number;\n  toRow: number;\n  fromRowId: unknown;\n  toRowId: unknown;\n  rowIds: unknown[];\n  updated: TUpdatedValue;\n  action: UpdateActions;\n  fromRowData: TRow;\n}\n\nexport interface CellCopyPasteEvent<TRow> {\n  cellKey: keyof TRow;\n  rowIdx: number;\n  fromRow: number;\n  toRow: number;\n  value: unknown;\n}\n\nexport interface CheckCellIsEditableEvent<TRow> extends Position {\n  row: TRow;\n  column: CalculatedColumn<TRow>;\n}\n\nexport interface RowSelectionParams<TRow> {\n  rowIdx: number;\n  row: TRow;\n}\n"]}