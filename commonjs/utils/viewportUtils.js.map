{"version":3,"file":"viewportUtils.js","sourceRoot":"","sources":["../../src/utils/viewportUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { isFrozen } from '../ColumnUtils';\nimport { SCROLL_DIRECTION } from '../common/enums';\nimport { CalculatedColumn, ColumnMetrics } from '../common/types';\n\nexport const OVERSCAN_ROWS = 2;\n\nconst { min, max, ceil, round } = Math;\n\nexport function getGridState<R>(props: { columnMetrics: ColumnMetrics<R>; rowsCount: number; minHeight: number; rowHeight: number; rowOffsetHeight: number }) {\n  const totalNumberColumns = props.columnMetrics.columns.length;\n  const canvasHeight = props.minHeight - props.rowOffsetHeight;\n  const renderedRowsCount = ceil((props.minHeight - props.rowHeight) / props.rowHeight);\n  const rowOverscanEndIdx = min(props.rowsCount, renderedRowsCount * 2);\n\n  return {\n    rowOverscanStartIdx: 0,\n    rowOverscanEndIdx,\n    rowVisibleStartIdx: 0,\n    rowVisibleEndIdx: renderedRowsCount,\n    height: canvasHeight,\n    scrollTop: 0,\n    scrollLeft: 0,\n    colVisibleStartIdx: 0,\n    colVisibleEndIdx: totalNumberColumns,\n    colOverscanStartIdx: 0,\n    colOverscanEndIdx: totalNumberColumns,\n    isScrolling: false,\n    lastFrozenColumnIndex: 0\n  };\n}\n\nexport function findLastFrozenColumnIndex<R>(columns: CalculatedColumn<R>[]): number {\n  return columns.findIndex(c => isFrozen(c));\n}\n\nfunction getTotalFrozenColumnWidth<R>(columns: CalculatedColumn<R>[]): number {\n  const lastFrozenColumnIndex = findLastFrozenColumnIndex(columns);\n  if (lastFrozenColumnIndex === -1) {\n    return 0;\n  }\n  const lastFrozenColumn = columns[lastFrozenColumnIndex];\n  return lastFrozenColumn.left + lastFrozenColumn.width;\n}\n\nfunction getColumnCountForWidth<R>(columns: CalculatedColumn<R>[], initialWidth: number, colVisibleStartIdx: number): number {\n  let width = initialWidth;\n  let count = 0;\n\n  columns.forEach((column, idx) => {\n    if (idx! >= colVisibleStartIdx) {\n      width -= column.width;\n      if (width >= 0) {\n        count++;\n      }\n    }\n  });\n\n  return count;\n}\n\nexport function getNonFrozenVisibleColStartIdx<R>(columns: CalculatedColumn<R>[], scrollLeft: number): number {\n  let remainingScroll = scrollLeft;\n  const lastFrozenColumnIndex = findLastFrozenColumnIndex(columns);\n  const nonFrozenColumns = columns.slice(lastFrozenColumnIndex + 1);\n  let columnIndex = lastFrozenColumnIndex;\n  while (remainingScroll >= 0 && columnIndex < nonFrozenColumns.length) {\n    columnIndex++;\n    const column = columns[columnIndex];\n    remainingScroll -= column ? column.width : 0;\n  }\n  return max(columnIndex, 0);\n}\n\nexport function getNonFrozenRenderedColumnCount<R>(columnMetrics: ColumnMetrics<R>, viewportDomWidth: number, scrollLeft: number): number {\n  const { columns, totalColumnWidth } = columnMetrics;\n  if (columns.length === 0) {\n    return 0;\n  }\n  const colVisibleStartIdx = getNonFrozenVisibleColStartIdx(columns, scrollLeft);\n  const totalFrozenColumnWidth = getTotalFrozenColumnWidth(columns);\n  const viewportWidth = viewportDomWidth > 0 ? viewportDomWidth : totalColumnWidth;\n  const firstColumn = columns[colVisibleStartIdx];\n  // calculate the portion width of first column hidden behind frozen columns\n  const scrolledFrozenWidth = totalFrozenColumnWidth + scrollLeft;\n  const firstColumnHiddenWidth = scrolledFrozenWidth > firstColumn.left ? scrolledFrozenWidth - firstColumn.left : 0;\n  const initialWidth = viewportWidth - totalFrozenColumnWidth + firstColumnHiddenWidth;\n  return getColumnCountForWidth(columns, initialWidth, colVisibleStartIdx);\n}\n\nexport interface VisibleBoundaries {\n  rowVisibleStartIdx: number;\n  rowVisibleEndIdx: number;\n}\n\nexport function getVisibleBoundaries(gridHeight: number, rowHeight: number, scrollTop: number, rowsCount: number): VisibleBoundaries {\n  const renderedRowsCount = ceil(gridHeight / rowHeight);\n  const rowVisibleStartIdx = max(0, round(scrollTop / rowHeight));\n  const rowVisibleEndIdx = min(rowVisibleStartIdx + renderedRowsCount, rowsCount);\n  return { rowVisibleStartIdx, rowVisibleEndIdx };\n}\n\ninterface ScrollState {\n  scrollTop?: number;\n  scrollLeft?: number;\n}\n\nexport function getScrollDirection(lastScroll: ScrollState, scrollTop: number, scrollLeft: number): SCROLL_DIRECTION {\n  if (scrollTop !== lastScroll.scrollTop && lastScroll.scrollTop !== undefined) {\n    return scrollTop - lastScroll.scrollTop >= 0 ? SCROLL_DIRECTION.DOWN : SCROLL_DIRECTION.UP;\n  }\n  if (scrollLeft !== lastScroll.scrollLeft && lastScroll.scrollLeft !== undefined) {\n    return scrollLeft - lastScroll.scrollLeft >= 0 ? SCROLL_DIRECTION.RIGHT : SCROLL_DIRECTION.LEFT;\n  }\n  return SCROLL_DIRECTION.NONE;\n}\n\nexport function getRowOverscanStartIdx(scrollDirection: SCROLL_DIRECTION, rowVisibleStartIdx: number): number {\n  return scrollDirection === SCROLL_DIRECTION.UP ? max(0, rowVisibleStartIdx - OVERSCAN_ROWS) : max(0, rowVisibleStartIdx);\n}\n\nexport function getRowOverscanEndIdx(scrollDirection: SCROLL_DIRECTION, rowVisibleEndIdx: number, rowsCount: number): number {\n  if (scrollDirection === SCROLL_DIRECTION.DOWN) {\n    const overscanBoundaryIdx = rowVisibleEndIdx + OVERSCAN_ROWS;\n    return min(overscanBoundaryIdx, rowsCount);\n  }\n  return rowVisibleEndIdx;\n}\n\nexport function getColOverscanStartIdx(scrollDirection: SCROLL_DIRECTION, colVisibleStartIdx: number, lastFrozenColumnIdx: number): number {\n  if (scrollDirection === SCROLL_DIRECTION.LEFT || scrollDirection === SCROLL_DIRECTION.RIGHT) {\n    return lastFrozenColumnIdx > -1 ? lastFrozenColumnIdx + 1 : 0;\n  }\n  return colVisibleStartIdx;\n}\n\nexport function getColOverscanEndIdx(scrollDirection: SCROLL_DIRECTION, colVisibleEndIdx: number, totalNumberColumns: number): number {\n  if (scrollDirection === SCROLL_DIRECTION.DOWN || scrollDirection === SCROLL_DIRECTION.UP) {\n    return colVisibleEndIdx;\n  }\n  return totalNumberColumns;\n}\n"]}